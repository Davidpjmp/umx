% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/misc_and_utility.R
\name{umx_graphviz_mat2dot}
\alias{umx_graphviz_mat2dot}
\title{Return dot code for paths in a matrix}
\usage{
umx_graphviz_mat2dot(x, cells = c("diag", "lower", "lower_inc", "upper",
  "upper_inc", "any", "left"), from = c("rows", "cols"),
  fromLabel = NULL, toLabel = NULL, selDVs = NULL,
  showFixed = FALSE, arrows = c("forward", "both", "back"),
  type = NULL, digits = 2, model = NULL, SEstyle = FALSE,
  p = list(str = "", latents = c(), manifests = c()))
}
\arguments{
\item{x}{a \code{\link{umxMatrix}} to make paths from.}

\item{cells}{which cells to process: "any" (default), "diag", "lower", "upper". "left" is the left half (e.g. in a twin means matrix)}

\item{from}{one of "rows", "columns" or a name}

\item{fromLabel}{= NULL}

\item{toLabel}{= NULL}

\item{selDVs}{if not null, row is used to index into this to set target name}

\item{showFixed}{= FALSE}

\item{arrows}{"forward" "both" or "back"}

\item{type}{one of "latent" or "manifest" (default NULL, don't accumulate new names using "from" list)}

\item{digits}{to round values to (default = 2).}

\item{model}{If you want to get CIs, you can pass in the model (default = NULL)}

\item{SEstyle}{If TRUE, CIs shown as "b(SE)" ("b \link{l,h}" if FALSE (default)). Ignored if model NULL.}

\item{p}{input to build on. list(str = "", latents = c(), manifests = c())}
}
\value{
\itemize{
\item list(str = "", latents = c(), manifests = c())
}
}
\description{
Return dot code for paths in a matrix is a function which walks the rows and cols of a matrix.
At each free cell, it creates a dot-string specifying the relevant path, e.g.:

\code{ai1 -> var1 [label=".35"]}

Its main use is to correctly generate paths (and their sources and sink objects)
without depending on the label of the parameter.

It is hihgly customisable:
\enumerate{
\item You can specify which cells to inspect, e.g. "lower".
\item You can choose how to interpret path direction, from = "cols".
\item You can choose the label for the from to ends of the path (by default, the matrix name is used).
\item You can offer up a selDVs list which will be
\item You can set the number of arrows on a path (e.g. both).
\item If \code{type} is set, then sources are added to the manifests or latents output (p)
}

Finally, you can pass in previous output and new paths will be concatendated to these.
}
\examples{

# Make a lower 3 * 3 value= 1:6 (1, 4, 6 on the diag)
a_cp = umxMatrix("a_cp", "Lower", 3, 3, free = TRUE, values = 1:6)

# Get dot strings for lower triangle (default from and to based on row and column number)
out = umx_graphviz_mat2dot(a_cp, cells = "lower", from = "cols", arrows = "both")
cat(out$str) # a_cp1 -> a_cp2 [dir = both label="2"];

# one arrow (the default = "forward")
out = umx_graphviz_mat2dot(a_cp, cells = "lower", from = "cols")
cat(out$str) # a_cp1 -> a_cp2 [dir = forward label="2"];

# label to (rows) using var names
out = umx_graphviz_mat2dot(a_cp, selDVs= c("var1", "var2", "var3"), cells = "lower", from = "cols")
cat(out$str) # a_cp1 -> a_cp2 [dir = both label="2"];

# First call also inits the plot struct
out = umx_graphviz_mat2dot(a_cp, from = "rows", cells = "lower", arrows = "both", type = "latent")
out = umx_graphviz_mat2dot(a_cp, from = "rows", cells = "diag" , toLabel= "common", type = "latent", p = out)
cat(out$str)

out = umx_graphviz_mat2dot(a_cp, from = "rows", cells = "diag" , selDVs= letters[1:3], type = "latent")
cat(out$str) # a_cp1 -> a [dir = forward label="1"]; a_cp2 -> b [dir = forward label="4"];

out = umx_graphviz_mat2dot(a_cp, from = "rows", cells = "diag" , selDVs= letters[1:3], type = "latent");
cat(out$str); cat(out$latents)
out = umx_graphviz_mat2dot(a_cp, from = "rows", cells = "diag" , selDVs= letters[1:3], type = "manifest");
cat(out$str); cat(out$manifests)

# ==============================================
# = Get a string which includes CI information =
# ==============================================
data(demoOneFactor)
latents = c("g"); manifests = names(demoOneFactor)
m1 = umxRAM("One Factor", data = demoOneFactor, type = "cov",
	umxPath(latents, to = manifests),
	umxPath(var = manifests),
	umxPath(var = latents, fixedAt = 1.0)
)
m1 = umxCI(m1, run= "yes")
out = umx_graphviz_mat2dot(m1$A, from = "cols", cells = "any", selDVs= paste0("x", 1:5), type = "latent", model= m1);
cat(out$str); cat(out$latents)
}
\seealso{
\itemize{
\item \code{\link{plot}}
}

Other Miscellaneous Utility Functions: \code{\link{install.OpenMx}},
  \code{\link{qm}}, \code{\link{umxBrownie}},
  \code{\link{umxFactor}}, \code{\link{umxVersion}},
  \code{\link{umx_array_shift}},
  \code{\link{umx_cell_is_on}},
  \code{\link{umx_cont_2_quantiles}},
  \code{\link{umx_find_object}},
  \code{\link{umx_graphviz_define_shapes}},
  \code{\link{umx_graphviz_rank}}, \code{\link{umx_make}},
  \code{\link{umx_msg}}, \code{\link{umx_open_CRAN_page}},
  \code{\link{umx_pad}}, \code{\link{umx_pb_note}},
  \code{\link{umx_print}}, \code{\link{umx_scale}},
  \code{\link{umx_score_scale}}, \code{\link{umx}},
  \code{\link{xmu_check_variance}}
}
\concept{Miscellaneous Utility Functions}
