% Generated by roxygen2 (4.0.0): do not edit by hand
\name{umxPath}
\alias{umxPath}
\title{umxPath: Flexible specification of sem paths}
\usage{
umxPath(from = NULL, to = NULL, with = NULL, var = NULL, cov = NULL,
  unique.bivariate = NULL, means = NULL, fixedAt = NULL, firstAt = NULL,
  connect = "single", arrows = 1, free = TRUE, values = NA,
  labels = NA, lbound = NA, ubound = NA)
}
\arguments{
\item{from}{either a source variable e.g "A" or c("A","B"), OR a sem-style path description, e.g. "A-> B" or "C <> B"}

\item{to}{one or more target variables for one-headed paths, e.g "A" or c("A","B")}

\item{with}{same as "to = vars, arrows = 2". nb: from, to= and var=  must be left empty (their default)}

\item{var}{equivalent to setting "from = vars, arrows = 2". nb: from, to, and with must be left empty (their default)}

\item{cov}{equivalent to setting "from = X, to = Y, arrows = 2". nb: from, to, and with must be left empty (their default)}

\item{unique.bivariate}{equivalent to setting "connect = "unique.bivariate", arrows = 2". nb: from, to, and with must be left empty (their default)}

\item{mean}{equivalent to setting "from = 'one', to = x. nb: from, to, with and var must be left empty (their default)}

\item{fixedAt}{Equivalent to setting "free = FALSE, values = x" nb: free and values must be left empty (their default)}

\item{firstAt}{first value is fixed at 1 (free is ignored: warning if not a single TRUE)}

\item{connect}{as in mxPath - nb: Only used when using from and to}

\item{arrows}{as in mxPath - nb: Only used when using from and to}

\item{free}{whether the value is free to be optimised}

\item{values}{default value list}

\item{labels}{labels for each path}

\item{lbound}{lower bounds for each path value}

\item{ubound}{upper bounds for each path value}
}
\value{
- \code{\link{mxPath}}
}
\description{
The goal of this function is to enable quck to write, quick to read, and flexible paths for RAM models in OpenMx.

The new key "with" means you no-longer need set arrows = 2 on covariances. So you can say:
   \code{mxPath(A, with = B)} instead of \code{mxPath(from = A, to = B, arrows = 2)}.

Dpecify a variance with \code{mxPath(var = A)} (equivalent to \code{mxPath(from = A, to = A, arrows = 2)}).

To specify a mean, you say \code{mxPath(mean = A)}, which is equivalent to \code{mxPath(from = "one", to = A)}.

To fix a patha at a value, you can say \code{mxPath(var = A, fixedAt = 1)} instead of to \code{mxPath(from = A, to = A, arrows = 2, free = F, values = 1)}.

Setting up a latent trait, you can fix the loading of the first path with \code{mxPath(A, to = c(B,C,D), fixFirst = T)} instead of
\code{mxPath(from = A, to = c(B,C,D), free = c(F, T, T), values = c(1, .5, .4))}.

Finally, you can use the John Fox "sem" package style notation, i.e., "A -> B".
If you want to add multiple paths that way, separate them with a semi-colon or a return (see examples below.)
}
\details{
This function returns a standard mxPath, but gives new options for specifying the path. In addition to the normal
from and to, it adds specialised parameters for variances (var), two headed paths (with) and means (mean).
There are also verbs for fixing values: "fixedAt" and "fixFirst"
Finally, it also allows sem-style "A->B" string specification.
}
\examples{
require(OpenMx)
# Some examples of paths with umxPath
umxPath("A", to = "B")
umxPath("A", to = "B", fixedAt = 1)
umxPath("A", to = LETTERS[2:4], firstAt = 1) # Same as "free = FALSE, values = 1"
umxPath("A", with = "B") # using with: same as "to = B, arrows = 2"
umxPath("A", with = "B", fixedAt = .5)
umxPath("A", with = "B", firstAt = 1)
umxPath("A", with = c("B","C"), fixedAt = 1)
umxPath(var = "A") # Give a variance to A
umxPath(var = "A", fixedAt = 1)
umxPath(var = LETTERS[1:5], fixedAt = 1)
umxPath(cov = c("A", "B")) # Covariance A <-> B
umxPath(means = c("A","B")) # Create a means model for A: from = "one", to = "A"
umxPath(means = c("A","B"), values = c(pi,exp(1)))
umxPath("A <-> B") # same path as above using a string
umxPath("A -> B") # one-headed arrow with string syntax
umxPath("A <> B; A <-- B") # This is ok too
umxPath("A -> B; B>C; C --> D") # two paths. space doesn't matter, hyphens don't matter
umxPath("A -> manifests") # manifests is a reserved word, as is latents. Allows string syntax to use the manifestVars variable
# A worked example
data(demoOneFactor)
latents  = c("G")
manifests = names(demoOneFactor)
m1 <- mxModel("One Factor", type = "RAM",
	manifestVars = manifests, latentVars = latents,
	umxPath(latents, to = manifests),
	# umxPath("G -> manifests"),
	mxPath(var = manifests),
	mxPath(var = latents, fixedAt = 1.0),
	mxData(cov(demoOneFactor), type = "cov", numObs = 500)
)
m1 = umxRun(m1, setLabels = T, setValues = T)
umxSummary(m1, show = "std")
}
\references{
- \url{https://github.com/tbates/umx}, \url{tbates.github.io}, \url{http://openmx.psyc.virginia.edu}
}
\seealso{
- \code{\link{umxLabel}}, \code{\link{mxMatrix}}, \code{\link{umxStart}}

Other umx build functions: \code{\link{umx_fix_first_loadings}};
  \code{\link{umx_fix_latents}}
}

